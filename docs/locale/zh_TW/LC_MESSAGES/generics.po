# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, test
# This file is distributed under the same license as the test package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: test 0.0.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-06-21 02:56+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: YUN CHEN <kweily632@gmail.com>, 2017\n"
"Language: zh_Hant_TW\n"
"Language-Team: Chinese (Taiwan) (https://www.transifex.com/django-"
"channels-tw-docs/teams/72101/zh_TW/)\n"
"Plural-Forms: nplurals=1; plural=0\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.4.0\n"

#: ../../generics.rst:2
msgid "Generic Consumers"
msgstr "一般消費者"

#: ../../generics.rst:4
msgid ""
"Much like Django's class-based views, Channels has class-based consumers."
" They provide a way for you to arrange code so it's highly modifiable and"
" inheritable, at the slight cost of it being harder to figure out the "
"execution path."
msgstr ""

#: ../../generics.rst:9
msgid ""
"We recommend you use them if you find them valuable; normal function-"
"based consumers are also entirely valid, however, and may result in more "
"readable code for simpler tasks."
msgstr ""

#: ../../generics.rst:13
msgid ""
"There is one base generic consumer class, ``BaseConsumer``, that provides"
" the pattern for method dispatch and is the thing you can build entirely "
"custom consumers on top of, and then protocol-specific subclasses that "
"provide extra utility - for example, the ``WebsocketConsumer`` provides "
"automatic group management for the connection."
msgstr ""

#: ../../generics.rst:19
msgid ""
"When you use class-based consumers in :doc:`routing <routing>`, you need "
"to use ``route_class`` rather than ``route``; ``route_class`` knows how "
"to talk to the class-based consumer and extract the list of channels it "
"needs to listen on from it directly, rather than making you pass it in "
"explicitly."
msgstr ""

#: ../../generics.rst:24
msgid "Here's a routing example::"
msgstr "這是一個路由案例:"

#: ../../generics.rst:33
msgid ""
"Class-based consumers are instantiated once for each message they "
"consume, so it's safe to store things on ``self`` (in fact, "
"``self.message`` is the current message by default, and ``self.kwargs`` "
"are the keyword arguments passed in from the routing)."
msgstr ""

#: ../../generics.rst:39
msgid "Base"
msgstr "基礎"

#: ../../generics.rst:41
msgid ""
"The ``BaseConsumer`` class is the foundation of class-based consumers, "
"and what you can inherit from if you wish to build your own entirely from"
" scratch."
msgstr ""

#: ../../generics.rst:44
msgid "You use it like this::"
msgstr "你使用它如這個："

#: ../../generics.rst:57
msgid ""
"All you need to define is the ``method_mapping`` dictionary, which maps "
"channel names to method names. The base code will take care of the "
"dispatching for you, and set ``self.message`` to the current message as "
"well."
msgstr ""

#: ../../generics.rst:61
msgid ""
"If you want to perfom more complicated routing, you'll need to override "
"the ``dispatch()`` and ``channel_names()`` methods in order to do the "
"right thing; remember, though, your channel names cannot change during "
"runtime and must always be the same for as long as your process runs."
msgstr ""

#: ../../generics.rst:66
msgid ""
"``BaseConsumer`` and all other generic consumers that inherit from it "
"provide two instance variables on the class:"
msgstr ""

#: ../../generics.rst:69
msgid ""
"``self.message``, the :ref:`Message object <ref-message>` representing "
"the message the consumer was called for."
msgstr ""

#: ../../generics.rst:71
msgid "``self.kwargs``, keyword arguments from the :doc:`routing`"
msgstr ""

#: ../../generics.rst:75
msgid "WebSockets"
msgstr ""

#: ../../generics.rst:77
msgid ""
"There are two WebSockets generic consumers; one that provides group "
"management, simpler send/receive methods, and basic method routing, and a"
" subclass which additionally automatically serializes all messages sent "
"and receives using JSON."
msgstr ""

#: ../../generics.rst:81
msgid "The basic WebSocket generic consumer is used like this::"
msgstr ""

#: ../../generics.rst:123
msgid ""
"You can call ``self.send`` inside the class to send things to the "
"connection's ``reply_channel`` automatically. Any group names returned "
"from ``connection_groups`` are used to add the socket to when it connects"
" and to remove it from when it disconnects; you get keyword arguments too"
" if your URL path, say, affects which group to talk to."
msgstr ""

#: ../../generics.rst:129
msgid ""
"Additionally, the property ``self.path`` is always set to the current URL"
" path."
msgstr "另外，\"self.path\"屬性只設於目前的URL路徑"

#: ../../generics.rst:131
msgid "The JSON-enabled consumer looks slightly different::"
msgstr ""

#: ../../generics.rst:175
msgid ""
"For this subclass, ``receive`` only gets a ``content`` argument that is "
"the already-decoded JSON as Python datastructures; similarly, ``send`` "
"now only takes a single argument, which it JSON-encodes before sending "
"down to the client."
msgstr ""

#: ../../generics.rst:180
msgid ""
"Note that this subclass still can't intercept ``Group.send()`` calls to "
"make them into JSON automatically, but it does provide "
"``self.group_send(name, content)`` that will do this for you if you call "
"it explicitly."
msgstr ""

#: ../../generics.rst:184
msgid ""
"``self.close()`` is also provided to easily close the WebSocket from the "
"server end with an optional status code once you are done with it."
msgstr ""

#: ../../generics.rst:190
msgid "WebSocket Multiplexing"
msgstr ""

#: ../../generics.rst:192
msgid ""
"Channels provides a standard way to multiplex different data streams over"
" a single WebSocket, called a ``Demultiplexer``."
msgstr ""

#: ../../generics.rst:195
msgid ""
"It expects JSON-formatted WebSocket frames with two keys, ``stream`` and "
"``payload``, and will match the ``stream`` against the mapping to find a "
"channel name. It will then forward the message onto that channel while "
"preserving ``reply_channel``, so you can hook consumers up to them "
"directly in the ``routing.py`` file, and use authentication decorators as"
" you wish."
msgstr ""

#: ../../generics.rst:202
msgid "Example using class-based consumer::"
msgstr "基於消費者的使用案例："

#: ../../generics.rst:237
msgid ""
"The ``multiplexer`` allows the consumer class to be independent of the "
"stream name. It holds the stream name and the demultiplexer on the "
"attributes ``stream`` and ``demultiplexer``."
msgstr ""

#: ../../generics.rst:240
msgid ""
"The :doc:`data binding <binding>` code will also send out messages to "
"clients in the same format, and you can encode things in this format "
"yourself by using the ``WebsocketDemultiplexer.encode`` class method."
msgstr ""

#: ../../generics.rst:246
msgid "Sessions and Users"
msgstr "會期和使用者"

#: ../../generics.rst:248
msgid ""
"If you wish to use ``channel_session`` or ``channel_session_user`` with a"
" class-based consumer, simply set one of the variables in the class "
"body::"
msgstr ""

#: ../../generics.rst:255
msgid ""
"This will run the appropriate decorator around your handler methods, and "
"provide ``message.channel_session`` and ``message.user`` on the message "
"object - both the one passed in to your handler as an argument as well as"
" ``self.message``, as they point to the same instance."
msgstr ""

#: ../../generics.rst:260
msgid ""
"And if you just want to use the user from the django session, add "
"``http_user``::"
msgstr ""

#: ../../generics.rst:266
msgid ""
"This will give you ``message.user``, which will be the same as "
"``request.user`` would be on a regular View."
msgstr ""

#: ../../generics.rst:271
msgid "Applying Decorators"
msgstr ""

#: ../../generics.rst:273
msgid ""
"To apply decorators to a class-based consumer, you'll have to wrap a "
"functional part of the consumer; in this case, ``get_handler`` is likely "
"the place you want to override; like so::"
msgstr ""

#: ../../generics.rst:283
msgid ""
"You can also use the Django ``method_decorator`` utility to wrap methods "
"that have ``message`` as their first positional argument - note that it "
"won't work for more high-level methods, like "
"``WebsocketConsumer.receive``."
msgstr ""

#: ../../generics.rst:289
msgid "As route"
msgstr ""

#: ../../generics.rst:291
msgid ""
"Instead of making routes using ``route_class`` you may use the "
"``as_route`` shortcut. This function takes route filters (:ref:`filters`)"
" as kwargs and returns ``route_class``. For example::"
msgstr ""

#: ../../generics.rst:301
msgid ""
"Use the ``attrs`` dict keyword for dynamic class attributes. For example "
"you have the generic consumer::"
msgstr ""

#: ../../generics.rst:311
msgid ""
"You can create consumers with different ``group`` and  ``group_prefix`` "
"with ``attrs``, like so::"
msgstr ""

#~ msgid ""
#~ "The ``multiplexer`` allows the consumer "
#~ "class to be independant of the "
#~ "stream name. It holds the stream "
#~ "name and the demultiplexer on the "
#~ "attributes ``stream`` and ``demultiplexer``."
#~ msgstr ""

